{"ast":null,"code":"// AI Tagging Service - Simulates intelligent document analysis\nclass AITaggingService {\n  constructor() {\n    this.documentPatterns = {\n      // Document type patterns\n      documentTypes: {\n        'PDF': ['.pdf'],\n        'Word': ['.doc', '.docx'],\n        'Excel': ['.xls', '.xlsx', '.csv'],\n        'PowerPoint': ['.ppt', '.pptx'],\n        'Image': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg'],\n        'Text': ['.txt', '.md', '.rtf']\n      },\n      // Project identification patterns\n      projects: [{\n        name: 'Project Alpha',\n        keywords: ['alpha', 'development', 'phase1', 'initial']\n      }, {\n        name: 'Project Beta',\n        keywords: ['beta', 'research', 'analysis', 'study']\n      }, {\n        name: 'Administrative',\n        keywords: ['admin', 'policy', 'procedure', 'hr', 'finance']\n      }, {\n        name: 'Client Work',\n        keywords: ['client', 'customer', 'proposal', 'contract']\n      }, {\n        name: 'Documentation',\n        keywords: ['manual', 'guide', 'specification', 'requirements']\n      }],\n      // Tag patterns based on content and context\n      tagPatterns: [{\n        tag: 'Important',\n        keywords: ['urgent', 'critical', 'important', 'priority', 'deadline'],\n        type: 'priority',\n        color: '#ff6b6b'\n      }, {\n        tag: 'Review Required',\n        keywords: ['review', 'check', 'verify', 'approve', 'draft'],\n        type: 'status',\n        color: '#ffd93d'\n      }, {\n        tag: 'Financial',\n        keywords: ['budget', 'cost', 'expense', 'invoice', 'payment', 'financial'],\n        type: 'category',\n        color: '#4ecdc4'\n      }, {\n        tag: 'Legal',\n        keywords: ['contract', 'agreement', 'legal', 'compliance', 'terms'],\n        type: 'category',\n        color: '#45b7d1'\n      }, {\n        tag: 'Technical',\n        keywords: ['technical', 'specification', 'architecture', 'design', 'implementation'],\n        type: 'category',\n        color: '#96ceb4'\n      }, {\n        tag: 'Meeting Notes',\n        keywords: ['meeting', 'notes', 'minutes', 'discussion', 'agenda'],\n        type: 'document_type',\n        color: '#feca57'\n      }, {\n        tag: 'Report',\n        keywords: ['report', 'summary', 'analysis', 'findings', 'results'],\n        type: 'document_type',\n        color: '#ff9ff3'\n      }, {\n        tag: 'Confidential',\n        keywords: ['confidential', 'private', 'sensitive', 'restricted', 'internal'],\n        type: 'security',\n        color: '#fd79a8'\n      }]\n    };\n  }\n  async analyzeDocument(file, metadata) {\n    // Simulate AI processing delay\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    const fileName = file.name.toLowerCase();\n    const fileExtension = '.' + fileName.split('.').pop();\n\n    // Extract content (simulated)\n    const extractedContent = await this.extractContent(file);\n\n    // Determine document type\n    const suggestedDocumentType = this.identifyDocumentType(fileExtension);\n\n    // Identify project\n    const suggestedProject = this.identifyProject(fileName, extractedContent);\n\n    // Generate tag suggestions\n    const suggestedTags = this.generateTagSuggestions(fileName, extractedContent);\n    return {\n      suggestedDocumentType,\n      suggestedProject,\n      suggestedTags,\n      extractedContent: extractedContent.substring(0, 500) + '...',\n      // Truncate for demo\n      confidence: this.calculateConfidence(suggestedTags, suggestedProject),\n      analysisTimestamp: new Date().toISOString()\n    };\n  }\n  async reAnalyzeDocument(document) {\n    // Simulate re-analysis with additional context from existing documents\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Re-analyze with potentially improved suggestions\n    const newAnalysis = await this.analyzeDocument({\n      name: document.name,\n      type: document.type\n    }, document);\n\n    // Add some variation to show \"learning\"\n    const enhancedSuggestions = this.enhanceWithContextualLearning(newAnalysis, document);\n    return enhancedSuggestions;\n  }\n  async extractContent(file) {\n    // Simulate content extraction based on file type\n    const fileName = file.name.toLowerCase();\n\n    // This would normally use libraries like pdf-parse, mammoth, etc.\n    const simulatedContent = this.generateSimulatedContent(fileName);\n    return simulatedContent;\n  }\n  generateSimulatedContent(fileName) {\n    const contentTemplates = {\n      'contract': 'This agreement is entered into between the parties for the provision of services. Terms and conditions apply. Payment due within 30 days.',\n      'report': 'Executive Summary: This report presents findings from our quarterly analysis. Key metrics show improvement in performance indicators.',\n      'meeting': 'Meeting Minutes: Attendees discussed project timeline and deliverables. Action items assigned to team members.',\n      'proposal': 'Project Proposal: We propose to implement a comprehensive solution that addresses the client requirements and objectives.',\n      'invoice': 'Invoice for services rendered. Amount due: $5,000. Payment terms: Net 30 days. Thank you for your business.',\n      'specification': 'Technical Specification Document: System requirements, architecture overview, and implementation guidelines.',\n      'manual': 'User Manual: Step-by-step instructions for system operation. Please follow safety guidelines and procedures.',\n      'policy': 'Company Policy: This document outlines procedures and guidelines for employee conduct and organizational standards.'\n    };\n\n    // Match filename to content template\n    for (const [key, content] of Object.entries(contentTemplates)) {\n      if (fileName.includes(key)) {\n        return content;\n      }\n    }\n\n    // Default content\n    return 'Document content analysis in progress. This file contains structured information relevant to business operations and documentation requirements.';\n  }\n  identifyDocumentType(fileExtension) {\n    for (const [type, extensions] of Object.entries(this.documentPatterns.documentTypes)) {\n      if (extensions.includes(fileExtension)) {\n        return type;\n      }\n    }\n    return 'Other';\n  }\n  identifyProject(fileName, content) {\n    const searchText = (fileName + ' ' + content).toLowerCase();\n    for (const project of this.documentPatterns.projects) {\n      const matchCount = project.keywords.filter(keyword => searchText.includes(keyword)).length;\n      if (matchCount > 0) {\n        return {\n          name: project.name,\n          confidence: Math.min(matchCount / project.keywords.length, 1.0)\n        };\n      }\n    }\n    return null;\n  }\n  generateTagSuggestions(fileName, content) {\n    const searchText = (fileName + ' ' + content).toLowerCase();\n    const suggestions = [];\n    for (const pattern of this.documentPatterns.tagPatterns) {\n      const matchCount = pattern.keywords.filter(keyword => searchText.includes(keyword)).length;\n      if (matchCount > 0) {\n        suggestions.push({\n          id: pattern.tag.toLowerCase().replace(/\\s+/g, '_'),\n          name: pattern.tag,\n          type: pattern.type,\n          color: pattern.color,\n          confidence: Math.min(matchCount / pattern.keywords.length, 1.0),\n          reason: `Matched keywords: ${pattern.keywords.filter(k => searchText.includes(k)).join(', ')}`\n        });\n      }\n    }\n\n    // Sort by confidence\n    return suggestions.sort((a, b) => b.confidence - a.confidence).slice(0, 5);\n  }\n  calculateConfidence(tags, project) {\n    let totalConfidence = 0;\n    let factors = 0;\n    if (tags && tags.length > 0) {\n      totalConfidence += tags.reduce((sum, tag) => sum + tag.confidence, 0) / tags.length;\n      factors++;\n    }\n    if (project && project.confidence) {\n      totalConfidence += project.confidence;\n      factors++;\n    }\n    return factors > 0 ? Math.round(totalConfidence / factors * 100) : 50;\n  }\n  enhanceWithContextualLearning(analysis, existingDocument) {\n    // Simulate learning from existing document patterns\n    const enhancedTags = [...analysis.suggestedTags];\n\n    // Add contextual suggestions based on document history\n    if (existingDocument.tags && existingDocument.tags.length > 0) {\n      enhancedTags.push({\n        id: 'previously_tagged',\n        name: 'Similar to Previous',\n        type: 'context',\n        color: '#a8e6cf',\n        confidence: 0.7,\n        reason: 'Based on your previous tagging patterns'\n      });\n    }\n    return {\n      ...analysis,\n      suggestedTags: enhancedTags.slice(0, 6),\n      // Limit suggestions\n      isReanalysis: true\n    };\n  }\n  async batchAnalyzeDocuments(documents) {\n    const results = [];\n    for (const document of documents) {\n      try {\n        const analysis = await this.reAnalyzeDocument(document);\n        results.push({\n          documentId: document.id,\n          analysis,\n          success: true\n        });\n      } catch (error) {\n        results.push({\n          documentId: document.id,\n          error: error.message,\n          success: false\n        });\n      }\n    }\n    return results;\n  }\n\n  // Simulate machine learning improvements over time\n  async trainFromUserFeedback(documentId, acceptedSuggestions, rejectedSuggestions) {\n    // In a real implementation, this would update ML models\n    console.log('Training from user feedback:', {\n      documentId,\n      accepted: acceptedSuggestions.length,\n      rejected: rejectedSuggestions.length\n    });\n\n    // Return updated model confidence\n    return {\n      modelUpdated: true,\n      newConfidence: Math.min(95, 75 + acceptedSuggestions.length * 5),\n      timestamp: new Date().toISOString()\n    };\n  }\n}\nexport const aiTaggingService = new AITaggingService();","map":{"version":3,"names":["AITaggingService","constructor","documentPatterns","documentTypes","projects","name","keywords","tagPatterns","tag","type","color","analyzeDocument","file","metadata","Promise","resolve","setTimeout","fileName","toLowerCase","fileExtension","split","pop","extractedContent","extractContent","suggestedDocumentType","identifyDocumentType","suggestedProject","identifyProject","suggestedTags","generateTagSuggestions","substring","confidence","calculateConfidence","analysisTimestamp","Date","toISOString","reAnalyzeDocument","document","newAnalysis","enhancedSuggestions","enhanceWithContextualLearning","simulatedContent","generateSimulatedContent","contentTemplates","key","content","Object","entries","includes","extensions","searchText","project","matchCount","filter","keyword","length","Math","min","suggestions","pattern","push","id","replace","reason","k","join","sort","a","b","slice","tags","totalConfidence","factors","reduce","sum","round","analysis","existingDocument","enhancedTags","isReanalysis","batchAnalyzeDocuments","documents","results","documentId","success","error","message","trainFromUserFeedback","acceptedSuggestions","rejectedSuggestions","console","log","accepted","rejected","modelUpdated","newConfidence","timestamp","aiTaggingService"],"sources":["C:/Users/bradley.worthen/OneDrive - Nortek, Inc/Documents/Projects/Document Management Web Application/src/services/aiTaggingService.js"],"sourcesContent":["// AI Tagging Service - Simulates intelligent document analysis\r\nclass AITaggingService {\r\n  constructor() {\r\n    this.documentPatterns = {\r\n      // Document type patterns\r\n      documentTypes: {\r\n        'PDF': ['.pdf'],\r\n        'Word': ['.doc', '.docx'],\r\n        'Excel': ['.xls', '.xlsx', '.csv'],\r\n        'PowerPoint': ['.ppt', '.pptx'],\r\n        'Image': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg'],\r\n        'Text': ['.txt', '.md', '.rtf']\r\n      },\r\n      \r\n      // Project identification patterns\r\n      projects: [\r\n        { name: 'Project Alpha', keywords: ['alpha', 'development', 'phase1', 'initial'] },\r\n        { name: 'Project Beta', keywords: ['beta', 'research', 'analysis', 'study'] },\r\n        { name: 'Administrative', keywords: ['admin', 'policy', 'procedure', 'hr', 'finance'] },\r\n        { name: 'Client Work', keywords: ['client', 'customer', 'proposal', 'contract'] },\r\n        { name: 'Documentation', keywords: ['manual', 'guide', 'specification', 'requirements'] }\r\n      ],\r\n      \r\n      // Tag patterns based on content and context\r\n      tagPatterns: [\r\n        { \r\n          tag: 'Important', \r\n          keywords: ['urgent', 'critical', 'important', 'priority', 'deadline'],\r\n          type: 'priority',\r\n          color: '#ff6b6b'\r\n        },\r\n        { \r\n          tag: 'Review Required', \r\n          keywords: ['review', 'check', 'verify', 'approve', 'draft'],\r\n          type: 'status',\r\n          color: '#ffd93d'\r\n        },\r\n        { \r\n          tag: 'Financial', \r\n          keywords: ['budget', 'cost', 'expense', 'invoice', 'payment', 'financial'],\r\n          type: 'category',\r\n          color: '#4ecdc4'\r\n        },\r\n        { \r\n          tag: 'Legal', \r\n          keywords: ['contract', 'agreement', 'legal', 'compliance', 'terms'],\r\n          type: 'category',\r\n          color: '#45b7d1'\r\n        },\r\n        { \r\n          tag: 'Technical', \r\n          keywords: ['technical', 'specification', 'architecture', 'design', 'implementation'],\r\n          type: 'category',\r\n          color: '#96ceb4'\r\n        },\r\n        { \r\n          tag: 'Meeting Notes', \r\n          keywords: ['meeting', 'notes', 'minutes', 'discussion', 'agenda'],\r\n          type: 'document_type',\r\n          color: '#feca57'\r\n        },\r\n        { \r\n          tag: 'Report', \r\n          keywords: ['report', 'summary', 'analysis', 'findings', 'results'],\r\n          type: 'document_type',\r\n          color: '#ff9ff3'\r\n        },\r\n        { \r\n          tag: 'Confidential', \r\n          keywords: ['confidential', 'private', 'sensitive', 'restricted', 'internal'],\r\n          type: 'security',\r\n          color: '#fd79a8'\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  async analyzeDocument(file, metadata) {\r\n    // Simulate AI processing delay\r\n    await new Promise(resolve => setTimeout(resolve, 1500));\r\n\r\n    const fileName = file.name.toLowerCase();\r\n    const fileExtension = '.' + fileName.split('.').pop();\r\n    \r\n    // Extract content (simulated)\r\n    const extractedContent = await this.extractContent(file);\r\n    \r\n    // Determine document type\r\n    const suggestedDocumentType = this.identifyDocumentType(fileExtension);\r\n    \r\n    // Identify project\r\n    const suggestedProject = this.identifyProject(fileName, extractedContent);\r\n    \r\n    // Generate tag suggestions\r\n    const suggestedTags = this.generateTagSuggestions(fileName, extractedContent);\r\n    \r\n    return {\r\n      suggestedDocumentType,\r\n      suggestedProject,\r\n      suggestedTags,\r\n      extractedContent: extractedContent.substring(0, 500) + '...', // Truncate for demo\r\n      confidence: this.calculateConfidence(suggestedTags, suggestedProject),\r\n      analysisTimestamp: new Date().toISOString()\r\n    };\r\n  }\r\n\r\n  async reAnalyzeDocument(document) {\r\n    // Simulate re-analysis with additional context from existing documents\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n    \r\n    // Re-analyze with potentially improved suggestions\r\n    const newAnalysis = await this.analyzeDocument(\r\n      { name: document.name, type: document.type }, \r\n      document\r\n    );\r\n    \r\n    // Add some variation to show \"learning\"\r\n    const enhancedSuggestions = this.enhanceWithContextualLearning(newAnalysis, document);\r\n    \r\n    return enhancedSuggestions;\r\n  }\r\n\r\n  async extractContent(file) {\r\n    // Simulate content extraction based on file type\r\n    const fileName = file.name.toLowerCase();\r\n    \r\n    // This would normally use libraries like pdf-parse, mammoth, etc.\r\n    const simulatedContent = this.generateSimulatedContent(fileName);\r\n    \r\n    return simulatedContent;\r\n  }\r\n\r\n  generateSimulatedContent(fileName) {\r\n    const contentTemplates = {\r\n      'contract': 'This agreement is entered into between the parties for the provision of services. Terms and conditions apply. Payment due within 30 days.',\r\n      'report': 'Executive Summary: This report presents findings from our quarterly analysis. Key metrics show improvement in performance indicators.',\r\n      'meeting': 'Meeting Minutes: Attendees discussed project timeline and deliverables. Action items assigned to team members.',\r\n      'proposal': 'Project Proposal: We propose to implement a comprehensive solution that addresses the client requirements and objectives.',\r\n      'invoice': 'Invoice for services rendered. Amount due: $5,000. Payment terms: Net 30 days. Thank you for your business.',\r\n      'specification': 'Technical Specification Document: System requirements, architecture overview, and implementation guidelines.',\r\n      'manual': 'User Manual: Step-by-step instructions for system operation. Please follow safety guidelines and procedures.',\r\n      'policy': 'Company Policy: This document outlines procedures and guidelines for employee conduct and organizational standards.'\r\n    };\r\n\r\n    // Match filename to content template\r\n    for (const [key, content] of Object.entries(contentTemplates)) {\r\n      if (fileName.includes(key)) {\r\n        return content;\r\n      }\r\n    }\r\n\r\n    // Default content\r\n    return 'Document content analysis in progress. This file contains structured information relevant to business operations and documentation requirements.';\r\n  }\r\n\r\n  identifyDocumentType(fileExtension) {\r\n    for (const [type, extensions] of Object.entries(this.documentPatterns.documentTypes)) {\r\n      if (extensions.includes(fileExtension)) {\r\n        return type;\r\n      }\r\n    }\r\n    return 'Other';\r\n  }\r\n\r\n  identifyProject(fileName, content) {\r\n    const searchText = (fileName + ' ' + content).toLowerCase();\r\n    \r\n    for (const project of this.documentPatterns.projects) {\r\n      const matchCount = project.keywords.filter(keyword => \r\n        searchText.includes(keyword)\r\n      ).length;\r\n      \r\n      if (matchCount > 0) {\r\n        return {\r\n          name: project.name,\r\n          confidence: Math.min(matchCount / project.keywords.length, 1.0)\r\n        };\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  generateTagSuggestions(fileName, content) {\r\n    const searchText = (fileName + ' ' + content).toLowerCase();\r\n    const suggestions = [];\r\n    \r\n    for (const pattern of this.documentPatterns.tagPatterns) {\r\n      const matchCount = pattern.keywords.filter(keyword => \r\n        searchText.includes(keyword)\r\n      ).length;\r\n      \r\n      if (matchCount > 0) {\r\n        suggestions.push({\r\n          id: pattern.tag.toLowerCase().replace(/\\s+/g, '_'),\r\n          name: pattern.tag,\r\n          type: pattern.type,\r\n          color: pattern.color,\r\n          confidence: Math.min(matchCount / pattern.keywords.length, 1.0),\r\n          reason: `Matched keywords: ${pattern.keywords.filter(k => searchText.includes(k)).join(', ')}`\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Sort by confidence\r\n    return suggestions.sort((a, b) => b.confidence - a.confidence).slice(0, 5);\r\n  }\r\n\r\n  calculateConfidence(tags, project) {\r\n    let totalConfidence = 0;\r\n    let factors = 0;\r\n    \r\n    if (tags && tags.length > 0) {\r\n      totalConfidence += tags.reduce((sum, tag) => sum + tag.confidence, 0) / tags.length;\r\n      factors++;\r\n    }\r\n    \r\n    if (project && project.confidence) {\r\n      totalConfidence += project.confidence;\r\n      factors++;\r\n    }\r\n    \r\n    return factors > 0 ? Math.round((totalConfidence / factors) * 100) : 50;\r\n  }\r\n\r\n  enhanceWithContextualLearning(analysis, existingDocument) {\r\n    // Simulate learning from existing document patterns\r\n    const enhancedTags = [...analysis.suggestedTags];\r\n    \r\n    // Add contextual suggestions based on document history\r\n    if (existingDocument.tags && existingDocument.tags.length > 0) {\r\n      enhancedTags.push({\r\n        id: 'previously_tagged',\r\n        name: 'Similar to Previous',\r\n        type: 'context',\r\n        color: '#a8e6cf',\r\n        confidence: 0.7,\r\n        reason: 'Based on your previous tagging patterns'\r\n      });\r\n    }\r\n    \r\n    return {\r\n      ...analysis,\r\n      suggestedTags: enhancedTags.slice(0, 6), // Limit suggestions\r\n      isReanalysis: true\r\n    };\r\n  }\r\n\r\n  async batchAnalyzeDocuments(documents) {\r\n    const results = [];\r\n    \r\n    for (const document of documents) {\r\n      try {\r\n        const analysis = await this.reAnalyzeDocument(document);\r\n        results.push({\r\n          documentId: document.id,\r\n          analysis,\r\n          success: true\r\n        });\r\n      } catch (error) {\r\n        results.push({\r\n          documentId: document.id,\r\n          error: error.message,\r\n          success: false\r\n        });\r\n      }\r\n    }\r\n    \r\n    return results;\r\n  }\r\n\r\n  // Simulate machine learning improvements over time\r\n  async trainFromUserFeedback(documentId, acceptedSuggestions, rejectedSuggestions) {\r\n    // In a real implementation, this would update ML models\r\n    console.log('Training from user feedback:', {\r\n      documentId,\r\n      accepted: acceptedSuggestions.length,\r\n      rejected: rejectedSuggestions.length\r\n    });\r\n    \r\n    // Return updated model confidence\r\n    return {\r\n      modelUpdated: true,\r\n      newConfidence: Math.min(95, 75 + acceptedSuggestions.length * 5),\r\n      timestamp: new Date().toISOString()\r\n    };\r\n  }\r\n}\r\n\r\nexport const aiTaggingService = new AITaggingService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}